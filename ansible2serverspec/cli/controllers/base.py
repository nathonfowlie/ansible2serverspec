####################################################################################################
# Copyright 2017 Nathon Fowlie
#
# Licensed under the Apache License, Version 2.0(the "License"); you may not use this file except in
# compliance with the License. You may obtain a copy of the License at
#
# http: // www.apache.org / licenses / LICENSE - 2.0
#
# Unless required by applicable law or agreed to in writing, software distributed under the License
# is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
# or implied. See the License for the specific language governing permissions and limitations under
# the License.
####################################################################################################

"""Ansible 2 ServerSpec base controller."""

import os
import sys
from ruamel.yaml import YAML
import json

# FIXME: Base controller needs to be changed to ArgparseController once the bug with unrecognised
# arguments is resolved.

from cement.core.controller import CementBaseController, expose
from argparse import SUPPRESS

from colorama import init, Fore, Back, Style

from ansible.parsing.dataloader import DataLoader
from ansible.vars import VariableManager
from ansible.inventory import Inventory
from ansible.playbook import Playbook
from ansible.cli.playbook import PlaybookCLI
from ansible.parsing.yaml.objects import AnsibleVaultEncryptedUnicode
from ansible.executor.playbook_executor import PlaybookExecutor
from ansible.utils.vars import load_extra_vars, load_options_vars

from ansible2serverspec.utils import constants
from ansible2serverspec import __banner__
from ansible2serverspec.utils import Options

# FIXME: ArgparseController must be used to support the _pre_argument_parsing method so that
# argument groups can be used. At the moment it appears that the new ArgparseController doesn't
# parse arguments correctly, as a result it will thrown unrecognised argument errors, even when
# specifying arguments in the A2SSBaseController.Meta.arguments array.
#class A2SSBaseController(ArgparseController):

class A2SSBaseController(CementBaseController):
    class Meta:
        label = 'base'
        ignore_unknown_arguments = True
        description = 'This utility can be used to export host variables generated by an Ansible ' \
                      'playbook to a YAML file, for later consumption by ServerSpec test scripts.'

        arguments = [
            (['--ask-vault-pass'], dict(help = 'ask for vault password', dest = 'ask_vault_pass', action = 'store_true', default = constants.DEFAULT_ASK_VAULT_PASS)),
            (['--extra-vars'], dict(help = 'set additional variables as key=value or YAML/JSON', dest = 'extra_vars', action = 'store', metavar = 'EXTRA_VARS', default = constants.DEFAULT_EXTRA_VARS)),
            (['--flush-cache'], dict(help = 'clear the fact cache', dest = 'flush_cache', action = 'store_true', default = constants.DEFAULT_FLUSH_CACHE)),
            (['-f', '--forks'], dict(help = "specify number of parallel processes to use (default={})".format(constants.DEFAULT_FORKS), dest = 'forks', action = 'store', metavar = 'FORKS', default = constants.DEFAULT_FORKS)),
            (['-i', '--inventory'], dict(help = "specify inventory host path (default={}) or comma separated host list.".format(constants.DEFAULT_INVENTORY), dest = 'inventory', action = 'store', metavar = 'INVENTORY', default = constants.DEFAULT_INVENTORY)),
            (['-l', '--limit'], dict(help = 'further limit selected hosts to an additional pattern.', dest = 'limit', action = 'store', metavar = 'SUBSET', default = constants.DEFAULT_SUBSET)),
            (['-M', '--module-path'], dict(help = "specify path(s) to module library (default={})".format(constants.DEFAULT_MODULE_PATH), dest = 'module_path', action = 'store', default = constants.DEFAULT_MODULE_PATH)),
            (['--skip-tags'], dict(help = 'only run plays and tasks whose tags do not match these values', dest = 'skip_tags', action = 'store', metavar = 'SKIP_TAGS', default = constants.DEFAULT_SKIP_TAGS)),
            (['-t', '--tags'], dict(help = 'only run plays and tasks tagged with these values', dest = 'tags', action = 'store', metavar = 'TAGS', default = constants.DEFAULT_TAGS)),
            (['-P', '--vault-password-file'], dict(help = 'vault password file', dest = 'vault_password_file', action = 'store', metavar = 'VAULT_PASSWORD_FILE', default = constants.DEFAULT_VAULT_PASSWORD_FILE)),
            (['-v', '--verbose'], dict(help = 'verbose mode', dest = 'verbose', action = 'store_true')),
            (['--version'], dict(action = 'version', version = __banner__)),
            (['-k', '--ask-pass'], dict(help = 'ask for connection password', dest = 'ask_pass', action = 'store_true', default = constants.DEFAULT_ASK_PASS)),
            (['--private-key', '--key-file'], dict(help = 'use this file to authenticate the connection', dest = 'private_key', action = 'store', metavar = 'PRIVATE_KEY_FILE', default = constants.DEFAULT_PRIVATE_KEY_FILE)),
            (['-u', '--user'], dict(help = "connect as this user (default={})".format(constants.DEFAULT_REMOTE_USER), dest = 'user', action = 'store', metavar = 'REMOTE_USER', default = constants.DEFAULT_REMOTE_USER)),
            (['-c', '--connection'], dict(help = "connection type to use ( default={})".format(constants.DEFAULT_TRANSPORT), dest = 'connection', action = 'store', metavar = 'CONNECTION', default = constants.DEFAULT_TRANSPORT)),
            (['-T', '--timeout'], dict(help = "override connection timeout in seconds (default={})".format(constants.DEFAULT_CONNECTION_TIMEOUT), dest = 'timeout', action = 'store', metavar = 'TIMEOUT', default = constants.DEFAULT_CONNECTION_TIMEOUT)),
            (['--ssh-common-args'], dict(help = 'specify common arguments to pass to sftp/scp/ssh (e.g. ProxyCommand). Note that extra arguments must be prefixed with a space due to a known ArgParser bug.', dest = 'ssh_common_args', action = 'store', metavar = 'SSH_COMMON_ARGS', default = constants.DEFAULT_SSH_COMMON_ARGS)),
            (['--sftp-extra-args'], dict(help='specify extra arguments to pass to sftp only (e.g. -f, -l). Note that extra arguments must be prefixed with a space due to a known ArgParser bug.', dest = 'sftp_extra_args', action = 'store', metavar = 'SFTP_EXTRA_ARGS', default = constants.DEFAULT_SFTP_EXTRA_ARGS)),
            (['--scp-extra-args'], dict(help='specify extra arguments to pass to scp only (e.g. -l). Note that extra arguments must be prefixed with a space due to a known ArgParser bug.', dest = 'scp_extra_args', action = 'store', metavar = 'SCP_EXTRA_ARGS', default = constants.DEFAULT_SCP_EXTRA_ARGS)),
            (['--ssh-extra-args'], dict(help = 'specify extra arguments to pass to ssh only (e.g. -R). Note that extra arguments must be prefixed with a space due to a known ArgParser bug.', dest = 'ssh_extra_args', action = 'store', metavar = 'SSH_EXTRA_ARGS', default = constants.DEFAULT_SSH_EXTRA_ARGS)),
            (['-b', '--become'], dict(help = 'run operations with become (does not imply password prompting)', dest = 'become', action = 'store_true', default = constants.DEFAULT_BECOME)),
            (['--become-method'], dict(help = "privilege escalation method to use (default={}), valid choices: [ sudo | su | pbrun | pfexec | doas | dzdo | ksu | runas ]".format(constants.DEFAULT_BECOME_METHOD), dest = 'become_method', action = 'store', metavar = 'BECOME_METHOD', default = constants.DEFAULT_BECOME_METHOD)),
            (['--become-user'], dict(help = "run operations as this user (default={})".format(constants.DEFAULT_BECOME_USER), dest = 'become_user', action = 'store', metavar = 'BECOME_USER', default = constants.DEFAULT_BECOME_USER)),
            (['-K', '--ask-become-pass'], dict(help = 'ask for privilege escalation password', dest = 'ask_become_pass', action = 'store_true', default = constants.DEFAULT_BECOME_ASK_PASS)),
            (['-o', '--output'], dict(help='dump the ansible variable dictionary to file.', dest = 'output', action='store', default=constants.DEFAULT_OUTPUT_LOCATION)),
            (['extra_arguments'], dict(action='store', nargs='*', help=SUPPRESS))
        ]

    # FIXME: This will nicely group arguments so the help output matches that of the ansible-playbook
    # command, however it causes ansible2serverspec to fail with unrecognised argument errors.
    # Need to look into why the arguments aren't recognised.
    #def _pre_argument_parsing(self):
    #    self._parser.usage = "ansible2serverspec playbook.yml"
    #
    #    options_group = self._parser.add_argument_group('Options')
    #    options_group.add_argument('--ask-vault-pass', help = 'ask for vault password', dest = 'ask_vault_pass', action = 'store_true', default = constants.DEFAULT_ASK_VAULT_PASS)
    #    options_group.add_argument('-e', '--extra-vars', help = 'set additional variables as key=value or YAML/JSON', dest = 'extra_vars', action = 'store', metavar = 'EXTRA_VARS', default = constants.DEFAULT_EXTRA_VARS)
    #    options_group.add_argument('--flush-cache', help = 'clear the fact cache', dest = 'flush_cache', action = 'store_true', default = constants.DEFAULT_FLUSH_CACHE)
    #    options_group.add_argument('-f', '--forks',  help = "specify number of parallel processes to use (default={})".format(constants.DEFAULT_FORKS), dest = 'forks', action = 'store', metavar = 'FORKS', default = constants.DEFAULT_FORKS)
    #    options_group.add_argument('-i', '--inventory', help = "specify inventory host path (default={}) or comma separated host list.".format(constants.DEFAULT_INVENTORY), dest = 'inventory', action = 'store', metavar = 'INVENTORY', default = constants.DEFAULT_INVENTORY)
    #    options_group.add_argument('-l', '--limit', help = 'further limit selected hosts to an additional pattern.', dest = 'limit', action = 'store', metavar = 'SUBSET', default = constants.DEFAULT_SUBSET)
    #    options_group.add_argument('-M', '--module-path',  help = "specify path(s) to module library (default={})".format(constants.DEFAULT_MODULE_PATH), dest = 'module_path', action = 'store', default = constants.DEFAULT_MODULE_PATH)
    #    options_group.add_argument('--skip-tags', help = 'only run plays and tasks whose tags do not match these values', dest = 'skip_tags', action = 'store', metavar = 'SKIP_TAGS', default = constants.DEFAULT_SKIP_TAGS)
    #    options_group.add_argument('-t', '--tags', help = 'only run plays and tasks tagged with these values', dest = 'tags', action = 'store', metavar = 'TAGS', default = constants.DEFAULT_TAGS)
    #    options_group.add_argument('-P', '--vault-password-file', help = 'vault password file', dest = 'vault_password_file', action = 'store', metavar = 'VAULT_PASSWORD_FILE', default = constants.DEFAULT_VAULT_PASSWORD_FILE)
    #    options_group.add_argument('-v', '--verbose', help = 'verbose mode', dest = 'verbose', action = 'store_true')
    #    options_group.add_argument('--version', action = 'version', version = __banner__)
    #
    #    connection_group = self._parser.add_argument_group('Connection Options')
    #    connection_group.add_argument('-k', '--ask-pass', help = 'ask for connection password', dest = 'ask_pass', action = 'store_true', default = constants.DEFAULT_ASK_PASS)
    #    connection_group.add_argument('--private-key', '--key-file', help = 'use this file to authenticate the connection', dest = 'private_key', action = 'store', metavar = 'PRIVATE_KEY_FILE', default = constants.DEFAULT_PRIVATE_KEY_FILE)
    #    connection_group.add_argument('-u', '--user', help = "connect as this user (default={})".format(constants.DEFAULT_REMOTE_USER), dest = 'user', action = 'store', metavar = 'REMOTE_USER', default = constants.DEFAULT_REMOTE_USER)
    #    connection_group.add_argument('-c', '--connection', help = "connection type to use ( default={})".format(constants.DEFAULT_TRANSPORT), dest = 'connection', action = 'store', metavar = 'CONNECTION', default = constants.DEFAULT_TRANSPORT)
    #    connection_group.add_argument('-T', '--timeout', help = "override connection timeout in seconds (default={})".format(constants.DEFAULT_CONNECTION_TIMEOUT), dest = 'timeout', action = 'store', metavar = 'TIMEOUT', default = constants.DEFAULT_CONNECTION_TIMEOUT)
    #    connection_group.add_argument('--ssh-common-args', help = 'specify common arguments to pass to sftp/scp/ssh (e.g. ProxyCommand). Note that extra arguments must be prefixed with a space due to a known ArgParser bug.', dest = 'ssh_common_args', action = 'store', metavar = 'SSH_COMMON_ARGS', default = constants.DEFAULT_SSH_COMMON_ARGS)
    #    connection_group.add_argument('--sftp-extra-args', help='specify extra arguments to pass to sftp only (e.g. -f, -l). Note that extra arguments must be prefixed with a space due to a known ArgParser bug.', dest = 'sftp_extra_args', action = 'store', metavar = 'SFTP_EXTRA_ARGS', default = constants.DEFAULT_SFTP_EXTRA_ARGS)
    #    connection_group.add_argument('--scp-extra-args', help='specify extra arguments to pass to scp only (e.g. -l). Note that extra arguments must be prefixed with a space due to a known ArgParser bug.', dest = 'scp_extra_args', action = 'store', metavar = 'SCP_EXTRA_ARGS', default = constants.DEFAULT_SCP_EXTRA_ARGS)
    #    connection_group.add_argument('--ssh-extra-args', help = 'specify extra arguments to pass to ssh only (e.g. -R). Note that extra arguments must be prefixed with a space due to a known ArgParser bug.', dest = 'ssh_extra_args', action = 'store', metavar = 'SSH_EXTRA_ARGS', default = constants.DEFAULT_SSH_EXTRA_ARGS)
    #
    #    escalation_group = self._parser.add_argument_group('Privilege Escalation Options')
    #    escalation_group.add_argument('-b', '--become', help = 'run operations with become (does not imply password prompting)', dest = 'become', action = 'store_true', default = constants.DEFAULT_BECOME)
    #    escalation_group.add_argument('--become-method', help = "privilege escalation method to use (default={}), valid choices: [ sudo | su | pbrun | pfexec | doas | dzdo | ksu | runas ]".format(constants.DEFAULT_BECOME_METHOD), dest = 'become_method', action = 'store', choices=('sudo', 'su', 'pbrun', 'pfexec', 'doas', 'dzdo', 'ksu', 'runas'), metavar = 'BECOME_METHOD', default = constants.DEFAULT_BECOME_METHOD)
    #    escalation_group.add_argument('--become-user', help = "run operations as this user (default={})".format(constants.DEFAULT_BECOME_USER), dest = 'become_user', action = 'store', metavar = 'BECOME_USER', default = constants.DEFAULT_BECOME_USER)
    #    escalation_group.add_argument('-K', '--ask-become-pass', help = 'ask for privilege escalation password', dest = 'ask_become_pass', action = 'store_true', default = constants.DEFAULT_BECOME_ASK_PASS)

    @expose(help = "Export ansible playbook variables to a yaml file.")
    def default(self):
        verbose = self.app.pargs.verbose

        init(autoreset = True)

        if len(self.app.pargs.extra_arguments) == 0:
            self.app.args.print_help()
            print(Fore.RED + 'Error! You must specify a playbook file to run')
            sys.exit(1)

        if str(self.app.pargs.become_method).upper() not in ['SUDO', 'SU', 'PBRUN', 'PFEXEC', 'DOAS', 'DZDO', 'KSU', 'RUNAS']:
            print(Fore.RED + 'Error! Become method must be one of sudo, su, pbrun, pfexec, doas, dzdo, ksu or runas.')
            sys.exit(1)

        #if len(self.app.pargs.extra_arguments) > 0:

        playbook_path = self.app.pargs.extra_arguments[0] if len(self.app.pargs.extra_arguments) > 0 else "site.yml"

        if not os.path.isfile(playbook_path):
            print(Fore.RED + 'Error! The playbook file does not exist')
            sys.exit(1)

        inventory_path = self.app.pargs.inventory

        if not os.path.isfile(inventory_path):
            print(Fore.RED + 'Error! The inventory file does not exist.')
            sys.exit(1)

        # Most of the code from here down is straight copy & paste from ansible source code,
        # with a few tweaks/hacks to clean up variables that we don't want to emit in the generated
        # YAML.
        loader = DataLoader()

        pb_cli = PlaybookCLI(sys.argv[1:])
        pb_cli.parse()

        # !!!!! WARNING: THESE WILL BE INCLUDED IN THE GENERATED YAML FILE !!!!!
        (ssh_pass, become_pass) = pb_cli.ask_passwords()
        passwords = {'conn_pass': ssh_pass, 'become_pass': become_pass}

        vault_pass = None

        if self.app.pargs.ask_vault_pass:
            vault_pass = pb_cli.ask_vault_passwords()
        else:
            vault_pass = pb_cli.read_vault_password_file(self.app.pargs.vault_password_file, loader)

        if vault_pass is not None:
            loader.set_vault_password(vault_pass)

        # create the inventory, and filter it based on the subset specified (if any)
        host_list = self.app.pargs.inventory if self.app.pargs.inventory else constants.DEFAULT_HOST_LIST

        # FIXME: This should parse any arguments provided via -e or --extra-vars. Currently it seems
        # to parse the argument value wrongly and returns
        # '_raw_params': '<last character in variable>'. This prevents the ability to use
        # --extra-vars when executing plays.
        variable_manager = VariableManager()

        options = Options(
            verbosity = self.app.pargs.verbose,
            inventory = self.app.pargs.inventory,
            subset = self.app.pargs.limit,
            extra_vars = [self.app.pargs.extra_vars],
            forks = self.app.pargs.forks,
            ask_vault_pass = self.app.pargs.ask_vault_pass,
            vault_password_files = self.app.pargs.vault_password_file,
            tags = self.app.pargs.tags,
            skip_tags = self.app.pargs.skip_tags,
            become = self.app.pargs.become,
            become_method = self.app.pargs.become_method,
            become_user = self.app.pargs.become_user,
            become_ask_pass = self.app.pargs.ask_become_pass,
            ask_pass = self.app.pargs.ask_pass,
            private_key_file = self.app.pargs.private_key,
            remote_user = self.app.pargs.user,
            connection = self.app.pargs.connection, timeout = self.app.pargs.timeout,
            ssh_common_args = self.app.pargs.ssh_common_args,
            sftp_extra_args = self.app.pargs.sftp_extra_args,
            ssh_extra_args = self.app.pargs.ssh_extra_args,
            scp_extra_args = self.app.pargs.scp_extra_args,
            flush_cache = self.app.pargs.flush_cache, module_path = self.app.pargs.module_path)

        inventory = Inventory(loader = loader, variable_manager = variable_manager,
                              host_list = host_list)

        variable_manager.extra_vars = load_extra_vars(loader = loader, options = options)
        #variable_manager.options_vars = load_options_vars(options)

        if self.app.pargs.flush_cache:
            inventory.refresh_inventory()

        no_hosts = False

        if len(inventory.list_hosts()) == 0:
            print(Fore.YELLOW + "Warning! Provided hosts list is empty, only localhost is available.")
            no_hosts = True

        # FIXME: Limit is currently ignored.
        inventory.subset(self.app.pargs.limit)

        if len(inventory.list_hosts()) == 0 and no_hosts is False:
            # Invalid limit
            print(Fore.RED + "Error! Specified --limit does not match any hosts.")
            sys.exit(1)

        play_data = loader.load_from_file(playbook_path)

        host_list = inventory.get_hosts(
            pattern = self.app.pargs.limit) if self.app.pargs.limit else inventory.get_hosts()

        playbook = Playbook(loader = loader).load(playbook_path, variable_manager = variable_manager, loader = loader)

        pbex = PlaybookExecutor(playbooks = playbook.get_plays(), inventory = inventory,
                                variable_manager = variable_manager, loader = loader,
                                options = options, passwords = passwords)

        # Ansible variables matching these strings will be excluded from the generated yaml content.
        ignored_elements = [
            'ansible_playbook_python',
            'ansible_version',
            'group_names',
            'inventory_hostname',
            'inventory_hostname_short',
            'omit',
            'playbook_dir',
            'role_names'
        ]

        json_data = {}

        for host in host_list:
            host_vars = host.get_vars()
            host_name = host_vars['ansible_host'] if 'ansible_host' in host_vars.keys() else host.get_name()

            for play in playbook.get_plays():
                loader.set_vault_password(vault_pass)
                all_vars = variable_manager.get_vars(loader = loader, play = play, host = host)

                json_data[host_name] = all_vars['vars']

                json_data[host_name]['ansible_groups'] = all_vars['group_names']
                json_data[host_name]['ansible_roles'] = all_vars['role_names']

                for elem in ignored_elements:
                    del json_data['{}'.format(host)][elem]

                json_data[host_name]['ansible_become_user'] = self.app.pargs.become_user

                if passwords['become_pass'] is not None:
                    json_data[host_name]['ansible_become_pass'] = passwords['become_pass']

                json_data[host_name]['ansible_become'] = self.app.pargs.become
                json_data[host_name]['ansible_become_method'] = self.app.pargs.become_method

                if self.app.pargs.ssh_extra_args:
                    json_data[host_name]['ansible_ssh_extra_args'] = self.app.pargs.ssh_extra_args

                if self.app.pargs.scp_extra_args:
                    json_data[host_name]['ansible_scp_extra_args'] = self.app.pargs.scp_extra_args

                if self.app.pargs.sftp_extra_args:
                    json_data[host_name]['ansible_sftp_extra_args'] = self.app.pargs.sftp_extra_args

                if self.app.pargs.ssh_common_args:
                    json_data[host_name]['ansible_ssh_common_args'] = self.app.pargs.ssh_common_args

                json_data[host_name]['ansible_connection_timeout'] = self.app.pargs.timeout
                json_data[host_name]['ansible_connection_method'] = self.app.pargs.connection

                if self.app.pargs.private_key:
                    json_data[host_name]['ansible_private_key'] = self.app.pargs.private_key

                json_data[host_name]['ansible_ask_pass'] = self.app.pargs.ask_pass

                if self.app.pargs.limit:
                    json_data[host_name]['ansible_limit'] = self.app.pargs.limit

                # FIXME: Extra vars needs to be processed by Ansible instead of dumping them
                # here as a "dumb" string.
                if self.app.pargs.extra_vars:
                    json_data[host_name]['ansible_extra_vars'] = self.app.pargs.extra_vars

            for key, value in json_data[host_name].iteritems():
                if type(value) is AnsibleVaultEncryptedUnicode:
                    json_data[host_name][key] = str(value)

        # Convert the processed python dictionary to a valid json string
        json_obj = json.dumps(json_data)

        # Take the json string, and convert it to a valid yaml string
        yml = YAML(typ = "safe", pure = True)
        yml.default_flow_style = False

        yml_obj = yml.load(json_obj)

        if self.app.pargs.output is None:
            yml.dump(yml_obj, sys.stdout)
        else:
            with open(self.app.pargs.output, 'w') as outfile:
                yml.dump(yml_obj, outfile)

            print(Fore.GREEN + "Ansible variable dictionary written to {}".format(self.app.pargs.output))

        sys.exit(1)
